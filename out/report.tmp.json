[{"type":"paragraph","text":"`DSGuard` spec"},{"type":"space"},{"type":"code","lang":"act","obj":{"isStatic":true,"name":"canCall","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","internal":false,"sig":"canCall(address,address,bytes4)","callData":"#abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD","signature":"canCall(address,address,bytes4)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes4"},"if":["#sizeWordStack(CD) <=Int 1250000000"],"interface":[["address","src"],["address","dst"],["bytes4","sig"]],"fname":"canCall","returns":["1"]},"cases":[{"act":{"isStatic":true,"name":"canCall","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","internal":false,"sig":"canCall(address,address,bytes4)","callData":"#abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD","signature":"canCall(address,address,bytes4)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes4"},"if":["#sizeWordStack(CD) <=Int 1250000000"],"interface":[["address","src"],["address","dst"],["bytes4","sig"]],"fname":"canCall","returns":["1"],"storage":{"ACCT_ID":[]}},"name":"DSGuard_canCall_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":3000000,"spec":"// DSGuard_canCall\nrule [DSGuard.canCall.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          \n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (VGas >=Int 3000000)))) ","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule B8C62F706B124098A30C7F7CFFA4D0FD49D75E86F2DAF70B782445C7E9D17600\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_canCall\nrule [DSGuard.canCall.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          \n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (VGas >=Int 3000000)))) \n\nendmodule\n","hash":"b8c62f706b124098a30c7f7cffa4d0fd49d75e86f2daf70b782445c7e9d17600","status":"????","gas_module":"requires \"data.k\"\n\nmodule b8c62f706b124098a30c7f7cffa4d0fd49d75e86f2daf70b782445c7e9d17600GAS\n  imports EVM-DATA\n\n\n\nendmodule"}],"text":"<div id=\"DSGuard_canCall(address,address,bytes4)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#DSGuard_canCall(address,address,bytes4)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour canCall of DSGuard\ninterface canCall(address src, address dst, bytes4 sig)\n\n\n\nreturns 1</code></pre></div>"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"permit-auth","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-auth.act","internal":false,"sig":"permit(bytes32,bytes32,bytes32)","callData":"#abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(bytes32,bytes32,bytes32)","types":{"ABI_src":"bytes32","ABI_dst":"bytes32","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)"],"interface":[["bytes32","src"],["bytes32","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval","true"],"owner":["Owner   ","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner"]},"cases":[{"act":{"isStatic":false,"name":"permit-auth","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-auth.act","internal":false,"sig":"permit(bytes32,bytes32,bytes32)","callData":"#abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(bytes32,bytes32,bytes32)","types":{"ABI_src":"bytes32","ABI_dst":"bytes32","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)"],"interface":[["bytes32","src"],["bytes32","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval","true"],"owner":["Owner   ","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner"]},"name":"DSGuard_permit-auth_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":3000000,"spec":"// DSGuard_permit-auth\nrule [DSGuard.permit-auth.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> .WordStack </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval => true)]        \n          [#DSGuard.owner <- (Owner    => Owner)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeBytes(32, ABI_src)\n  andBool (#rangeBytes(32, ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0))))))))))))) ","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-auth.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule B73B8560C74D67BE8E7130261462CBB5A11228AD2F982E0437873E918D2DE102\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_permit-auth\nrule [DSGuard.permit-auth.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> .WordStack </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval => true)]        \n          [#DSGuard.owner <- (Owner    => Owner)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeBytes(32, ABI_src)\n  andBool (#rangeBytes(32, ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0))))))))))))) \n\nendmodule\n","hash":"b73b8560c74d67be8e7130261462cbb5a11228ad2f982e0437873e918d2de102","status":"reject","gas_module":"requires \"data.k\"\n\nmodule b73b8560c74d67be8e7130261462cbb5a11228ad2f982e0437873e918d2de102GAS\n  imports EVM-DATA\n\n\n\nendmodule"},{"act":{"isStatic":false,"name":"permit-auth","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-auth.act","internal":false,"sig":"permit(bytes32,bytes32,bytes32)","callData":"#abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(bytes32,bytes32,bytes32)","types":{"ABI_src":"bytes32","ABI_dst":"bytes32","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)"],"interface":[["bytes32","src"],["bytes32","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval","true"],"owner":["Owner   ","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"DSGuard_permit-auth_fail_rough","spec":"// DSGuard_permit-auth\nrule [DSGuard.permit-auth.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval => _)]        \n          [#DSGuard.owner <- (Owner    => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeBytes(32, ABI_src)\n  andBool (#rangeBytes(32, ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool (VGas >=Int 3000000)))))))))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-auth.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule 9DF42441D2B7837C8978FEA74F8F6841525B0CD0F1BF540043D23C8035E47046\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_permit-auth\nrule [DSGuard.permit-auth.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #bytes32(ABI_src), #bytes32(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval => _)]        \n          [#DSGuard.owner <- (Owner    => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeBytes(32, ABI_src)\n  andBool (#rangeBytes(32, ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool (VGas >=Int 3000000)))))))))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"9df42441d2b7837c8978fea74f8f6841525b0cd0f1bf540043d23c8035e47046","status":"????","gas_module":"requires \"data.k\"\n\nmodule 9df42441d2b7837c8978fea74f8f6841525b0cd0f1bf540043d23c8035e47046GAS\n  imports EVM-DATA\n\n\n\nendmodule"}],"text":"<div id=\"DSGuard_permit(bytes32,bytes32,bytes32)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#DSGuard_permit(bytes32,bytes32,bytes32)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour permit-auth of DSGuard\ninterface permit(bytes32 src, bytes32 dst, bytes32 sig)\n\ntypes\n  Approval  : bool\n  Owner     : address\n  Authority : address\nstorage\n  <span class=\"comment\">// </span>\n  acl[src][dst][sig] |-> Approval => true\n  <span class=\"comment\">// </span>\n  owner              |-> Owner    => Owner\n\niff\n  VCallValue == 0\n\nif\n  CALLER_ID == Owner</code></pre></div>"}]