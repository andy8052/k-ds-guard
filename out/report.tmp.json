[{"type":"paragraph","text":"`DSGuard` spec"},{"type":"space"},{"type":"code","lang":"act","obj":{"isStatic":true,"name":"owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_owner.act","internal":false,"sig":"owner()","callData":"#abiCallData(\"owner\", .TypedArgs) ++ CD","signature":"owner()","types":{"Owner":"address"},"if":["#sizeWordStack(CD) <=Int 1250000000","#notPrecompileAddress(Owner)"],"interface":[],"fname":"owner","storage":{"ACCT_ID":{"owner":["Owner","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"returns":["Owner"]},"cases":[{"act":{"isStatic":true,"name":"owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_owner.act","internal":false,"sig":"owner()","callData":"#abiCallData(\"owner\", .TypedArgs) ++ CD","signature":"owner()","types":{"Owner":"address"},"if":["#sizeWordStack(CD) <=Int 1250000000","#notPrecompileAddress(Owner)"],"interface":[],"fname":"owner","storage":{"ACCT_ID":{"owner":["Owner","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"returns":["Owner"]},"name":"DSGuard_owner_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":3000000,"spec":"// DSGuard_owner\nrule [DSGuard.owner.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(Owner, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"owner\", .TypedArgs) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.owner <- (Owner => Owner)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(Owner)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (#notPrecompileAddress(Owner)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0)))))) ","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_owner.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule 4BA2E55055B338334A01C1387AB48872649A0E08775C9CEB2BB729A721A956C5\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_owner\nrule [DSGuard.owner.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(Owner, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"owner\", .TypedArgs) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.owner <- (Owner => Owner)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(Owner)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (#notPrecompileAddress(Owner)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0)))))) \n\nendmodule\n","hash":"4ba2e55055b338334a01c1387ab48872649a0e08775c9ceb2bb729a721a956c5","status":"????","gas_module":"requires \"data.k\"\n\nmodule 4ba2e55055b338334a01c1387ab48872649a0e08775c9ceb2bb729a721a956c5GAS\n  imports EVM-DATA\n\n\n\nendmodule"},{"act":{"isStatic":true,"name":"owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_owner.act","internal":false,"sig":"owner()","callData":"#abiCallData(\"owner\", .TypedArgs) ++ CD","signature":"owner()","types":{"Owner":"address"},"if":["#sizeWordStack(CD) <=Int 1250000000","#notPrecompileAddress(Owner)"],"interface":[],"fname":"owner","storage":{"ACCT_ID":{"owner":["Owner","Owner"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"returns":["Owner"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"DSGuard_owner_fail_rough","spec":"// DSGuard_owner\nrule [DSGuard.owner.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"owner\", .TypedArgs) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.owner <- (Owner => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(Owner)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (#notPrecompileAddress(Owner)\n  andBool (VGas >=Int 3000000))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_owner.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule 9C70A0D473F7577149542A977479C558598EFB2C79128F7AF89D8DE88A2B2F73\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_owner\nrule [DSGuard.owner.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"owner\", .TypedArgs) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.owner <- (Owner => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(Owner)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (#notPrecompileAddress(Owner)\n  andBool (VGas >=Int 3000000))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"9c70a0d473f7577149542a977479c558598efb2c79128f7af89d8de88a2b2f73","status":"????","gas_module":"requires \"data.k\"\n\nmodule 9c70a0d473f7577149542a977479c558598efb2c79128f7af89d8de88a2b2f73GAS\n  imports EVM-DATA\n\n\n\nendmodule"}],"text":"<div id=\"DSGuard_owner()\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#DSGuard_owner()\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour owner of DSGuard\ninterface owner()\n\ntypes\n  Owner : address\n\nstorage\n  <span class=\"comment\">// </span>\n  owner |-> Owner => Owner\n\niff\n  VCallValue == 0\n\nreturns Owner</code></pre></div>"},{"type":"code","lang":"act","obj":{"isStatic":true,"name":"canCall","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","internal":false,"sig":"canCall(address,address,bytes4)","callData":"#abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD","signature":"canCall(address,address,bytes4)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes4"},"if":["#sizeWordStack(CD) <=Int 1250000000"],"interface":[["address","src"],["address","dst"],["bytes4","sig"]],"fname":"canCall","returns":["1"]},"cases":[{"act":{"isStatic":true,"name":"canCall","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","internal":false,"sig":"canCall(address,address,bytes4)","callData":"#abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD","signature":"canCall(address,address,bytes4)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes4"},"if":["#sizeWordStack(CD) <=Int 1250000000"],"interface":[["address","src"],["address","dst"],["bytes4","sig"]],"fname":"canCall","returns":["1"],"storage":{"ACCT_ID":[]}},"name":"DSGuard_canCall_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":3000000,"spec":"// DSGuard_canCall\nrule [DSGuard.canCall.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          \n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (VGas >=Int 3000000)))) ","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_canCall.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule DA7DB5CA87576BA10D6AF2407C4D49730AD6333A08F887B8A1E06BF6177FF055\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_canCall\nrule [DSGuard.canCall.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"canCall\", #address(ABI_src), #address(ABI_dst), #bytes4(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> _ </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          \n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#sizeWordStack(CD) <=Int 1250000000\n  andBool (VGas >=Int 3000000)))) \n\nendmodule\n","hash":"da7db5ca87576ba10d6af2407c4d49730ad6333a08f887b8a1e06bf6177ff055","status":"????","gas_module":"requires \"data.k\"\n\nmodule da7db5ca87576ba10d6af2407c4d49730ad6333a08f887b8a1e06bf6177ff055GAS\n  imports EVM-DATA\n\n\n\nendmodule"}],"text":"<div id=\"DSGuard_canCall(address,address,bytes4)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#DSGuard_canCall(address,address,bytes4)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour canCall of DSGuard\ninterface canCall(address src, address dst, bytes4 sig)\n\n\n\nreturns 1</code></pre></div>"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"permit-address-owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-address-owner.act","internal":false,"sig":"permit(address,address,bytes32)","callData":"#abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(address,address,bytes32)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)","(ACCT_ID =/=Int CALLER_ID)"],"interface":[["address","src"],["address","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval ","true"],"owner":["Owner    ","Owner"],"authority":["Authority","Authority"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner","ACCT_ID =/= CALLER_ID"]},"cases":[{"act":{"isStatic":false,"name":"permit-address-owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-address-owner.act","internal":false,"sig":"permit(address,address,bytes32)","callData":"#abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(address,address,bytes32)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)","(ACCT_ID =/=Int CALLER_ID)"],"interface":[["address","src"],["address","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval ","true"],"owner":["Owner    ","Owner"],"authority":["Authority","Authority"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner","ACCT_ID =/= CALLER_ID"]},"name":"DSGuard_permit-address-owner_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":3000000,"spec":"// DSGuard_permit-address-owner\nrule [DSGuard.permit-address-owner.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> .WordStack </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval  => true)]        \n          [#DSGuard.owner <- (Owner     => Owner)]        \n          [#DSGuard.authority <- (Authority => Authority)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool ((ACCT_ID =/=Int CALLER_ID)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0)))))))))))))) ","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-address-owner.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule 0345F34F77748B57C664868BD0F88E2AC3A46EE6EC08E05FE6406AFDE4D5CDF5\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_permit-address-owner\nrule [DSGuard.permit-address-owner.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> .WordStack </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval  => true)]        \n          [#DSGuard.owner <- (Owner     => Owner)]        \n          [#DSGuard.authority <- (Authority => Authority)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool ((ACCT_ID =/=Int CALLER_ID)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0)))))))))))))) \n\nendmodule\n","hash":"0345f34f77748b57c664868bd0f88e2ac3a46ee6ec08e05fe6406afde4d5cdf5","status":"reject","gas_module":"requires \"data.k\"\n\nmodule 0345f34f77748b57c664868bd0f88e2ac3a46ee6ec08e05fe6406afde4d5cdf5GAS\n  imports EVM-DATA\n\n\n\nendmodule"},{"act":{"isStatic":false,"name":"permit-address-owner","subject":"DSGuard","varname2alias":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-address-owner.act","internal":false,"sig":"permit(address,address,bytes32)","callData":"#abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD","signature":"permit(address,address,bytes32)","types":{"ABI_src":"address","ABI_dst":"address","ABI_sig":"bytes32","Approval":"bool","Owner":"address","Authority":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Owner))","(#notPrecompileAddress(Authority))","(CALLER_ID ==Int Owner)","(ACCT_ID =/=Int CALLER_ID)"],"interface":[["address","src"],["address","dst"],["bytes32","sig"]],"fname":"permit","storage":{"ACCT_ID":{"acl[src][dst][sig]":["Approval ","true"],"owner":["Owner    ","Owner"],"authority":["Authority","Authority"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["CALLER_ID == Owner","ACCT_ID =/= CALLER_ID"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"DSGuard_permit-address-owner_fail_rough","spec":"// DSGuard_permit-address-owner\nrule [DSGuard.permit-address-owner.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval  => _)]        \n          [#DSGuard.owner <- (Owner     => _)]        \n          [#DSGuard.authority <- (Authority => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool ((ACCT_ID =/=Int CALLER_ID)\n  andBool (VGas >=Int 3000000))))))))))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"DSGuard"},"act_name":"DSGuard_permit-address-owner.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\n\nmodule EE36E35D6E4F010826A525C1606C54AE2A4A549BC553D20CE4B35A26ED0B74BA\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n  \n\n// DSGuard_permit-address-owner\nrule [DSGuard.permit-address-owner.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(DSGuard_bin_runtime, PETERSBURG)) </program>\n        <programBytes> DSGuard_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"permit\", #address(ABI_src), #address(ABI_dst), #bytes32(ABI_sig)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> DSGuard_bin_runtime </code>\n          <storage>         \n           .Map \n          [#DSGuard.acl[ABI_src][ABI_dst][ABI_sig] <- (Approval  => _)]        \n          [#DSGuard.owner <- (Owner     => _)]        \n          [#DSGuard.authority <- (Authority => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_src)\n  andBool (#rangeAddress(ABI_dst)\n  andBool (#rangeBytes(32, ABI_sig)\n  andBool (#rangeUInt(1, Approval)\n  andBool (#rangeAddress(Owner)\n  andBool (#rangeAddress(Authority)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Owner))\n  andBool ((#notPrecompileAddress(Authority))\n  andBool ((CALLER_ID ==Int Owner)\n  andBool ((ACCT_ID =/=Int CALLER_ID)\n  andBool (VGas >=Int 3000000))))))))))))\n  andBool notBool (\n    ((VCallValue ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"ee36e35d6e4f010826a525c1606c54ae2a4a549bc553d20ce4b35a26ed0b74ba","status":"????","gas_module":"requires \"data.k\"\n\nmodule ee36e35d6e4f010826a525c1606c54ae2a4a549bc553d20ce4b35a26ed0b74baGAS\n  imports EVM-DATA\n\n\n\nendmodule"}],"text":"<div id=\"DSGuard_permit(address,address,bytes32)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#DSGuard_permit(address,address,bytes32)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour permit-address-owner of DSGuard\ninterface permit(address src, address dst, bytes32 sig)\n\ntypes\n  Approval  : bool\n  Owner     : address\n  Authority : address\n\nstorage\n  <span class=\"comment\">// </span>\n  acl[src][dst][sig] |-> Approval  => true\n  <span class=\"comment\">// </span>\n  owner              |-> Owner     => Owner\n  <span class=\"comment\">// </span>\n  authority          |-> Authority => Authority\n\niff\n  VCallValue == 0\n\nif\n  CALLER_ID == Owner\n  ACCT_ID =/= CALLER_ID</code></pre></div>"}]